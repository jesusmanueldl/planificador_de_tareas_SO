
package principal;


import java.util.LinkedList;
import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableModel;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.category.DefaultCategoryDataset;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author manuel
 */
public class Planificador extends javax.swing.JFrame {
    
    private int cuanto;
    private static DefaultTableModel dtm,dtm2;
    private ButtonGroup grupo1 = new ButtonGroup();   
    private Proceso proceso;  
    private LinkedList<Proceso> listo = new LinkedList();
    private LinkedList<Proceso> terminado = new LinkedList();
    private int unidadT = 60000;
    private float pfcfs = 0,pjsf = 0,prr = 0;

    /**
     * Creates new form Planificador
     */
    public Planificador() {
        initComponents();
        this.setLocationRelativeTo(null);
        
        
       
        grupo1.add(rbfcfs);       
        grupo1.add(rbnoapropia);
        grupo1.add(rbapropia);
        grupo1.add(rbrr);
        
        
        dtm = (DefaultTableModel) tabla.getModel();
        dtm2 = (DefaultTableModel) tablaresul.getModel();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jMenuItem1 = new javax.swing.JMenuItem();
        jMenu3 = new javax.swing.JMenu();
        jMenuBar2 = new javax.swing.JMenuBar();
        jMenu4 = new javax.swing.JMenu();
        jMenu5 = new javax.swing.JMenu();
        jMenuBar3 = new javax.swing.JMenuBar();
        jMenu6 = new javax.swing.JMenu();
        jMenu7 = new javax.swing.JMenu();
        jScrollPane4 = new javax.swing.JScrollPane();
        jEditorPane1 = new javax.swing.JEditorPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        tabla = new javax.swing.JTable();
        ejecuatar = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        tablaresul = new javax.swing.JTable();
        jLabel3 = new javax.swing.JLabel();
        lbespera = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        lbentrega = new javax.swing.JLabel();
        jlalgo = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jmproceso = new javax.swing.JMenu();
        generarProceso = new javax.swing.JMenuItem();
        agregarProceso = new javax.swing.JMenuItem();
        eliminarProceso = new javax.swing.JMenuItem();
        limpiarTablas = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        rbfcfs = new javax.swing.JRadioButtonMenuItem();
        jMenu1 = new javax.swing.JMenu();
        rbnoapropia = new javax.swing.JRadioButtonMenuItem();
        rbapropia = new javax.swing.JRadioButtonMenuItem();
        cbpriori = new javax.swing.JCheckBoxMenuItem();
        rbrr = new javax.swing.JRadioButtonMenuItem();
        jMenu8 = new javax.swing.JMenu();
        graficar = new javax.swing.JMenuItem();

        jMenuItem1.setText("jMenuItem1");

        jMenu3.setText("jMenu3");

        jMenu4.setText("File");
        jMenuBar2.add(jMenu4);

        jMenu5.setText("Edit");
        jMenuBar2.add(jMenu5);

        jMenu6.setText("File");
        jMenuBar3.add(jMenu6);

        jMenu7.setText("Edit");
        jMenuBar3.add(jMenu7);

        jScrollPane4.setViewportView(jEditorPane1);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Planificacion de procesos");
        setResizable(false);

        tabla.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Procesos", "T-llegada", "T-CPU", "Prioridad"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        jScrollPane1.setViewportView(tabla);

        ejecuatar.setText("Ejecutar");
        ejecuatar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ejecuatarActionPerformed(evt);
            }
        });

        tablaresul.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Procesos", "T-espera", "T-entrega", "Throughput", "T-respuesta"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane3.setViewportView(tablaresul);

        jLabel3.setText("Tiempo promedio de espera: ");

        lbespera.setText("...");

        jLabel5.setText("Tiempo promedio de entrega: ");

        lbentrega.setText("...");

        jlalgo.setText("-");

        jmproceso.setText("Proceso");

        generarProceso.setText("Generar");
        generarProceso.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generarProcesoActionPerformed(evt);
            }
        });
        jmproceso.add(generarProceso);

        agregarProceso.setText("Agregar");
        agregarProceso.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                agregarProcesoActionPerformed(evt);
            }
        });
        jmproceso.add(agregarProceso);

        eliminarProceso.setText("Eliminar");
        eliminarProceso.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                eliminarProcesoActionPerformed(evt);
            }
        });
        jmproceso.add(eliminarProceso);

        limpiarTablas.setText("LimpiarTablas");
        limpiarTablas.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                limpiarTablasActionPerformed(evt);
            }
        });
        jmproceso.add(limpiarTablas);

        jMenuBar1.add(jmproceso);

        jMenu2.setText("Algoritmo");

        rbfcfs.setText("FCFS");
        jMenu2.add(rbfcfs);

        jMenu1.setText("JSF");

        rbnoapropia.setText("No Apropiativo");
        jMenu1.add(rbnoapropia);

        rbapropia.setText("Apropiativo");
        jMenu1.add(rbapropia);

        cbpriori.setText("Prioridad");
        jMenu1.add(cbpriori);

        jMenu2.add(jMenu1);

        rbrr.setText("RR");
        rbrr.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbrrActionPerformed(evt);
            }
        });
        jMenu2.add(rbrr);

        jMenuBar1.add(jMenu2);

        jMenu8.setText("Ver");

        graficar.setText("Grafica");
        graficar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                graficarActionPerformed(evt);
            }
        });
        jMenu8.add(graficar);

        jMenuBar1.add(jMenu8);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jScrollPane3)
                        .addComponent(ejecuatar, javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                            .addComponent(jLabel3)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(lbespera))
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                            .addComponent(jLabel5)
                            .addGap(23, 23, 23)
                            .addComponent(lbentrega)))
                    .addComponent(jlalgo))
                .addContainerGap(26, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jlalgo)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ejecuatar)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 128, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lbespera))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lbentrega)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void generarProcesoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generarProcesoActionPerformed
        // TODO add your handling code here:
        limpiarTabla();
        int n_proceso = 0;        
        
        try{
    		n_proceso = Integer.parseInt(JOptionPane.showInputDialog(null,"Digite el total de procesos\n"));
    	}catch(Exception ex){
    		JOptionPane.showMessageDialog(this, "Error de numero de procesos", null, JOptionPane.ERROR_MESSAGE);
        }
    
        
        for(int i = 0; i < n_proceso; i++)
        {
            proceso = new Proceso("P"+i,(int) (Math.random() * 5),(int) (Math.random() * 10) + 1, (int) (Math.random() * 6));
            Object data[] = {proceso.getNombre(), proceso.getT_llegada(), proceso.getT_CPU(), proceso.getPrioridad()};
            dtm.addRow(data);            
        }
        
    }//GEN-LAST:event_generarProcesoActionPerformed

    private void eliminarProcesoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_eliminarProcesoActionPerformed
        // TODO add your handling code here:
        int i = tabla.getSelectedRow();                
        if(i >= 0 )
        {
            dtm.removeRow(i);			
        }
        else
        {
            JOptionPane.showMessageDialog(null,"Seleccione un proceso");
        }
    }//GEN-LAST:event_eliminarProcesoActionPerformed

    private void agregarProcesoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_agregarProcesoActionPerformed
        // TODO add your handling code here:
        //limpiarTabla();        
        Object data[] = null;
        dtm.addRow(data);
    }//GEN-LAST:event_agregarProcesoActionPerformed

    private void rbrrActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbrrActionPerformed
        // TODO add your handling code here:
        
        try{
    		cuanto = Integer.parseInt(JOptionPane.showInputDialog(null,"Digite el cuanto\n"));
    	}catch(Exception ex){
    		JOptionPane.showMessageDialog(this, "Error de cuanto", null, JOptionPane.ERROR_MESSAGE);
        }
        
    }//GEN-LAST:event_rbrrActionPerformed

    private void ejecuatarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ejecuatarActionPerformed
        // TODO add your handling code here:
        try
        { 
            if(dtm.getRowCount() > 0)
            {
                limpiaTablaDos();

                LinkedList<Proceso> listaP = new LinkedList();
                
                /**fcfs**/
                if(rbfcfs.isSelected())
                {
                    jlalgo.setText("FCFS");
                    obtenerDatos(listaP);            
                    ordenarListaDeLlegada(listaP);
                    algoritmoFCFS(listaP);
                    pfcfs = promedioRendimeinto();
                }
                
                /**si jsf no apropiativo y con prioridad***/
                else if(rbnoapropia.isSelected() && cbpriori.isSelected())
                {
                    jlalgo.setText("JSF-No apropiativo-prioridad");
                    obtenerDatos(listaP);
                    ordenarListaPrioridad(listaP);
                    algoritmoJSF_NA_CP(listaP);
                    pjsf = promedioRendimeinto();
                    
                }
                
                /**si jsf apropiativo y con prioridad***/
                else if(rbapropia.isSelected() && cbpriori.isSelected())
                {
                    jlalgo.setText("JSF-Apropiativo-prioridad");
                    
                }
                
                /**si jsf no apropiativo y sin prioridad***/
                else if(rbnoapropia.isSelected())
                {
                    jlalgo.setText("JSF-No Apropiativo");
                    obtenerDatos(listaP);
                    ordenarListaDeLlegada(listaP);                    
                    algoritmoJSF_NA_SP(listaP);
                    pjsf = promedioRendimeinto();
                }
                
                 /**si jsf apropiativo y sin prioridad***/
                else if(rbapropia.isSelected())
                {
                    jlalgo.setText("JSF-Apropiativo");
                    obtenerDatos(listaP);
                    algoritmoJSF_A_SP(listaP);                    
                    
                }
                
                /**Round Robin**/
                else if(rbrr.isSelected())
                {
                    jlalgo.setText("Round Robin");
                    obtenerDatos(listaP);
                    ordenarListaDeLlegada(listaP);
                    algoritmoRoundRobin(listaP);
                    prr = promedioRendimeinto();
                }
            }
            else
            {
                JOptionPane.showMessageDialog(this, "Sin procesos", null, JOptionPane.INFORMATION_MESSAGE);
            }
        }
        catch(Exception e){}
        
    }//GEN-LAST:event_ejecuatarActionPerformed

    private void limpiarTablasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_limpiarTablasActionPerformed
        // TODO add your handling code here:
        limpiarTabla();
        
    }//GEN-LAST:event_limpiarTablasActionPerformed
    /**
     * grafica el rendimiento de los distintos algoritmos
     * @param evt 
     */
    private void graficarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_graficarActionPerformed
        // TODO add your handling code here:
       DefaultCategoryDataset dataset = new DefaultCategoryDataset();
        
            dataset.addValue(pfcfs, "Proc-Unidad-Tiempo (1min)", "FCFS");
            dataset.addValue(pjsf, "Proc-Unidad-Tiempo (1min)", "JSF");
            dataset.addValue(prr, "Proc-Unidad-Tiempo (1min)", "Round-Robin");        

            JFreeChart chart = ChartFactory.createBarChart("Rendimiento por Algoritmo","Procesos", "Proc-Unidad-Tiempo (1min)", dataset, PlotOrientation.VERTICAL,false, true, false);

            ChartPanel panel = new ChartPanel(chart);

            JFrame ventana = new JFrame("El grafico");
            ventana.getContentPane().add(panel);
            ventana.pack();
            ventana.setVisible(true);
            ventana.setLocationRelativeTo(null);
            ventana.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);;
    }//GEN-LAST:event_graficarActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Planificador.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Planificador.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Planificador.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Planificador.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try{
                    UIManager.setLookAndFeel("javax.swing.plaf.metal.MetalLookAndFeel");
                }catch(Exception e){}
                new Planificador().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem agregarProceso;
    private javax.swing.JCheckBoxMenuItem cbpriori;
    private javax.swing.JButton ejecuatar;
    private javax.swing.JMenuItem eliminarProceso;
    private javax.swing.JMenuItem generarProceso;
    private javax.swing.JMenuItem graficar;
    private javax.swing.JEditorPane jEditorPane1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenu jMenu3;
    private javax.swing.JMenu jMenu4;
    private javax.swing.JMenu jMenu5;
    private javax.swing.JMenu jMenu6;
    private javax.swing.JMenu jMenu7;
    private javax.swing.JMenu jMenu8;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuBar jMenuBar2;
    private javax.swing.JMenuBar jMenuBar3;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JLabel jlalgo;
    private javax.swing.JMenu jmproceso;
    private javax.swing.JLabel lbentrega;
    private javax.swing.JLabel lbespera;
    private javax.swing.JMenuItem limpiarTablas;
    private javax.swing.JRadioButtonMenuItem rbapropia;
    private javax.swing.JRadioButtonMenuItem rbfcfs;
    private javax.swing.JRadioButtonMenuItem rbnoapropia;
    private javax.swing.JRadioButtonMenuItem rbrr;
    private javax.swing.JTable tabla;
    private javax.swing.JTable tablaresul;
    // End of variables declaration//GEN-END:variables

    /**
     * ordena la lista por prioridad
     * @param listaP 
     */
    public void ordenarListaPrioridad(LinkedList<Proceso> listaP) {
       
        Proceso procesoActual, procesoAux;
       
        for(int i = 0; i < listaP.size(); i++)
        {   
            for(int j = 0; j < listaP.size() - 1; j++)
            {
                 procesoActual = listaP.get(j);
                 procesoAux = listaP.get(j + 1);                
                if(procesoActual.getPrioridad() > procesoAux.getPrioridad())
                {
                    listaP.set(j, procesoAux);
                    listaP.set(j + 1, procesoActual);                    
                }
            }
        }
       
    }
    
    /**
     * ordena la lista en orden de llegada
     * @param listaP 
     */    
    public void ordenarListaDeLlegada(LinkedList<Proceso> listaP) {
       
        Proceso procesoActual, procesoAux;
       
        for(int i = 0; i < listaP.size(); i++)
        {   
            for(int j = 0; j < listaP.size() - 1; j++)
            {
                 procesoActual = listaP.get(j);
                 procesoAux = listaP.get(j + 1);                
                if(procesoActual.getT_llegada() > procesoAux.getT_llegada())
                {
                    listaP.set(j, procesoAux);
                    listaP.set(j + 1, procesoActual);                    
                }
            }
        }
       
    }
    
    /**
     * ordena la lista en orden del trabajo mas corto
     * @param listaP 
     */    
    public void ordenarListaTrabajocorto(LinkedList<Proceso> listaP) {
        
        Proceso procesoActual, procesoAux;
       
        for(int i = 0; i < listaP.size(); i++)
        {  
            for(int j = 0; j < listaP.size() - 1; j++)
            {
                 procesoActual = listaP.get(j);
                 procesoAux = listaP.get(j + 1);                
                if(procesoActual.getT_CPU() > procesoAux.getT_CPU())
                {
                    listaP.set(j, procesoAux);
                    listaP.set(j + 1, procesoActual);                    
                }
            }
        }
        
    }
    
    /**
     * obtiene los datos de los procesos
     * @param listaP 
     * @return lista de procesos
     */
    public void obtenerDatos(LinkedList<Proceso> listaP) {       
        
        for(int i = 0; i < dtm.getRowCount(); i++)
        { 
            proceso = new Proceso((String) dtm.getValueAt(i, 0),(int) dtm.getValueAt(i, 1),(int) dtm.getValueAt(i, 2),(int) dtm.getValueAt(i, 3));
            listaP.add(proceso);
        }
    }
    
    /**
     * calcula los procesos que estan en un tienpo determinado
     * @param time
     * @param listaP
     * @param listA
     * @return Boolean
     */    
    public boolean procesoEntiempo(int time, LinkedList<Proceso> listaP,LinkedList<Proceso> listA) {
        
        Proceso tempo[] = new Proceso[listaP.size()];
        
        boolean flag = false;
        
        for(int i = 0; i < listaP.size(); i++)
        {
            tempo[i] = listaP.get(i);
        }
        listaP.clear();
           
        for(int i = 0; i < tempo.length; i++)
        {
            if(tempo[i].getT_llegada() == time)
            {
                listA.add(tempo[i]);
                tempo[i] = null;
                flag = true;
            }
        }
        
        for(int i = 0; i < tempo.length; i++)
        {
            if(tempo[i] != null)
            {
                listaP.add(tempo[i]);
            }
        }
        
        return flag;
    }
    
    /**
     * existe proceso en el tiempo T
     * @param time
     * @param listaP
     * @return Boolean
     */
    public boolean procesoEntiempo(int time, LinkedList<Proceso> listaP) {
        
        boolean flag = false;        
       
        for(int i = 0; i < listaP.size(); i++)
        {
            if(listaP.get(i).getT_llegada() == time)
            {              
                flag = true;
                break;
            }
        }
        
        return flag;
    }

    public void limpiarTabla() {
                
        while(dtm.getRowCount() > 0)
        {
            dtm.removeRow(0);            
        }
        
        limpiaTablaDos();       
    }
    
    public void limpiaTablaDos()
    {
        /*****limpio la tabla 2*******/
        if(dtm2.getRowCount() > 0)
        {
            while(dtm2.getRowCount() > 0)
            {
                dtm2.removeRow(0);            
            }
        }
        /****************************/
        lbespera.setText("...");
        lbentrega.setText("...");
    }

    public void promedioEspera() {
        
        int espera = 0;
        float t = 0;
        for(int i = 0; i < dtm2.getRowCount(); i++)
            espera += (int) dtm2.getValueAt(i, 1);
        
        t = (float) (espera / dtm2.getRowCount());        
        lbespera.setText(t +" ms");
    }

    public void promedioEntrega() {
        
        int entrega = 0;
        float t;
        for(int i = 0; i < dtm2.getRowCount(); i++)
            entrega += (int) dtm2.getValueAt(i, 2);
        
        t = (entrega / dtm2.getRowCount());
        lbentrega.setText(t +" ms"); 
    }
    
    public float promedioRendimeinto()
    {
        int rend = 0;
        float t;
        for(int i = 0; i < dtm2.getRowCount(); i++)
            rend += (int) dtm2.getValueAt(i, 3);
        
        t = (rend / dtm2.getRowCount());
        
        return t;
        
    }
    
    
    /********************************
     *  ALGORITMOS DE PLANIFICACION *
     *  AUTOR:  JesÃºs Mauel DL      *
     ********************************/
    
    /*
     * algortimo: FCFS
     */
    
    public void algoritmoFCFS(LinkedList<Proceso> listaP) { 
                    
        int t_entrega = 0;
        int espera = 0;
                
        for(int i = 0; i < listaP.size(); i++)
        { 
            if(i > 0)
            {
                if(listaP.get(i - 1).getT_entrega() - listaP.get(i).getT_llegada() < 0)
                {
                    espera = 0;
                    t_entrega = listaP.get(i).getT_llegada() + listaP.get(i).getT_CPU();
                }
                else
                {
                    espera = listaP.get(i - 1).getT_entrega() - listaP.get(i).getT_llegada();
                    t_entrega = listaP.get(i - 1).getT_entrega() + listaP.get(i).getT_CPU();
                }
            }
            else
            {
                espera = 0;
                t_entrega = listaP.get(i).getT_llegada() + listaP.get(i).getT_CPU();
            }
            
            listaP.get(i).setT_espera(espera);
            listaP.get(i).setT_entrega(t_entrega);                    
            terminado.add(listaP.get(i));
        }
        
        for(int i = 0; i < terminado.size(); i++)
        {
            //espera, entrega, throughtput, respuesta
            Object data[] = {terminado.get(i).getNombre(),terminado.get(i).getT_espera() ,terminado.get(i).getT_entrega(),(unidadT / terminado.get(i).getT_entrega()),terminado.get(i).getT_llegada()};
            dtm2.addRow(data);
        }
        terminado.clear();
        listo.clear();        
        promedioEspera();
        promedioEntrega();
    }
    
    /*
     * algortimo: JSF apropiativo sin prioridad
     */    
    public void algoritmoJSF_NA_SP(LinkedList<Proceso> listaP) {
        
        int t_entrega = 0;
        int espera = 0;
        listo.add(listaP.get(0)); 
        listaP.poll();
        
        ordenarListaTrabajocorto(listaP);
        
        for(int i = 0; i < listaP.size(); i++)      
            listo.add(listaP.get(i));
        
        for(int i = 0; i < listo.size(); i++)
        {
            if(i > 0)
            {
                if(listo.get(i - 1).getT_entrega() - listo.get(i).getT_llegada() < 0)
                {
                    espera = 0;
                    t_entrega = listo.get(i).getT_llegada() + listo.get(i).getT_CPU();
                }
                else
                {
                    espera = listo.get(i - 1).getT_entrega() - listo.get(i).getT_llegada();
                    t_entrega = listo.get(i - 1).getT_entrega() + listo.get(i).getT_CPU();
                }
            }
            else
            {
                espera = 0;
                t_entrega = listo.get(i).getT_llegada() + listo.get(i).getT_CPU();
            }
            
            listo.get(i).setT_espera(espera);
            listo.get(i).setT_entrega(t_entrega);                    
            terminado.add(listo.get(i));
        }
        
        for(int i = 0; i < terminado.size(); i++)
        {
            //espera, entrega, throughtput, respuesta
            Object data[] = {terminado.get(i).getNombre(),terminado.get(i).getT_espera() ,terminado.get(i).getT_entrega(),(unidadT / terminado.get(i).getT_entrega()),terminado.get(i).getT_llegada()};
            dtm2.addRow(data);
        }
        terminado.clear();
        listo.clear();        
        promedioEspera();
        promedioEntrega();        
    }
    
    /*
     * algortimo: JSF apropiativo con prioridad
     */    
    public void algoritmoJSF_NA_CP(LinkedList<Proceso> listaP) {
        
        int t_entrega = 0;
        int espera = 0;
        listo.add(listaP.get(0)); 
        listaP.poll();
        
        for(int i = 0; i < listaP.size(); i++)      
            listo.add(listaP.get(i));
        
        for(int i = 0; i < listo.size(); i++)
        {
            if(i > 0)
            {
                if(listo.get(i - 1).getT_entrega() - listo.get(i).getT_llegada() < 0)
                {
                    espera = 0;
                    t_entrega = listo.get(i).getT_llegada() + listo.get(i).getT_CPU();
                }
                else
                {
                    espera = listo.get(i - 1).getT_entrega() - listo.get(i).getT_llegada();
                    t_entrega = listo.get(i - 1).getT_entrega() + listo.get(i).getT_CPU();
                }
            }
            else
            {
                espera = 0;
                t_entrega = listo.get(i).getT_llegada() + listo.get(i).getT_CPU();
            }
            
            listo.get(i).setT_espera(espera);
            listo.get(i).setT_entrega(t_entrega);                    
            terminado.add(listo.get(i));
        }
        
        for(int i = 0; i < terminado.size(); i++)
        {
            //espera, entrega, throughtput, respuesta
            Object data[] = {terminado.get(i).getNombre(),terminado.get(i).getT_espera() ,terminado.get(i).getT_entrega(),(unidadT / terminado.get(i).getT_entrega()),terminado.get(i).getT_llegada()};
            dtm2.addRow(data);
        }
        terminado.clear();
        listo.clear();        
        promedioEspera();
        promedioEntrega();
    }
    
    /*
     * algortimo: JSF no apropiativo sin prioridad
     */
    public void algoritmoJSF_A_SP(LinkedList<Proceso> listaP) {
        
        LinkedList<Proceso> listAux = new LinkedList();        
        int time = 0;
        Proceso proc1 = null;
        while(listaP.size() > 0 || listAux.size() > 0 || proc1 != null)
        {
            System.out.println(time);
            if(proc1 != null)
                proc1.setT_CPU(proc1.getT_CPU() - 1);
            
            if(listaP.isEmpty())
            {
                ordenarListaTrabajocorto(listAux);
                if(proc1.getT_CPU() > listAux.get(0).getT_CPU())
                {
                    listAux.add(proc1);
                    proc1 = listAux.get(0);
                    listAux.poll();
                    System.out.println(proc1.getNombre()+" entro con "+proc1.getT_CPU());
                }
                else if(proc1.getT_CPU() == 0)
                {                   
                    System.out.println(proc1.getNombre()+" termino "+proc1.getT_CPU());
                    proc1 = listAux.get(0);
                }
                   
            }
            else if(procesoEntiempo(time,listaP))
            {
                 procesoEntiempo(time,listaP,listAux);
                 ordenarListaTrabajocorto(listAux);
                 if(proc1 != null)
                 {
                     if(proc1.getT_CPU() > listAux.get(0).getT_CPU())
                     {
                        System.out.println(proc1.getNombre()+" entro a la cola con "+proc1.getT_CPU());
                        listAux.add(proc1);
                        proc1 = listAux.get(0);
                        System.out.println(proc1.getNombre());
                        listAux.poll();
                     }
                 }
                 else
                 {
                     proc1 = listAux.get(0);
                     System.out.println(proc1.getNombre()+" entro con "+proc1.getT_CPU());
                     listAux.poll();
                 }
                 
            }
            
            ordenarListaTrabajocorto(listAux);
            if(proc1.getT_CPU() > listAux.get(0).getT_CPU())
            {
                listAux.add(proc1);
                proc1 = listAux.get(0); 
                System.out.println(proc1.getNombre());
                listAux.poll();
                System.out.println(proc1.getNombre()+" entro con "+proc1.getT_CPU());
            }
            
            if(proc1 != null)
            {
                if(proc1.getT_CPU() > 0)
                {                   
                    System.out.println(proc1.getNombre()+" resta "+proc1.getT_CPU());
                }
                else
                {
                    System.out.println(proc1.getNombre()+" termino con "+proc1.getT_CPU());
                    ordenarListaTrabajocorto(listAux);                   
                    proc1 = listAux.get(0);
                    System.out.println(proc1.getNombre()+" entro con "+proc1.getT_CPU());
                    listAux.poll();
                    
                }
            }
            
            time ++;                
        }
    }

           
    
    /*
     * algortimo: RoundRobin
     */
    public void algoritmoRoundRobin(LinkedList<Proceso> listaP) {
        
        int tiempo = 0;
        int time = 0;
        int espera = 0;        
        Proceso proc;
        time = listaP.get(0).getT_llegada();
        
        while(listaP.size() > 0)
        { 
            tiempo = 0; 
            espera = listaP.get(0).getT_espera();
            espera += time - listaP.get(0).getT_llegada();
            if(espera < 0)
                espera = 0;
            listaP.get(0).setT_espera(espera);           
            //System.out.println("en el tiempo "+time+" entro "+listaP.get(0).getNombre());            
            
            while(tiempo < cuanto)
            {
                if(listaP.get(0).getT_CPU() > 0)
                {
                    listaP.get(0).setT_CPU(listaP.get(0).getT_CPU() - 1);
                }
                else
                {                    
                    break;
                }
                tiempo ++;
                time ++;                
            }
            
            if(listaP.get(0).getT_CPU() == 0)
            {
                listaP.get(0).setT_entrega(time);
                terminado.add(listaP.get(0));
                /*System.out.println("salio "+listaP.get(0).getNombre());
                System.out.println("espero "+listaP.get(0).getT_espera());*/
                listaP.poll();
                espera = 0;
            }
            else
            {     
                proc = listaP.get(0);
                listaP.poll();                
                proc.setT_llegada(time);                
                listaP.add(proc);
               /* System.out.println("espero "+proc.getT_espera());
                System.out.println("le restan "+proc.getT_CPU());
                System.out.println("entro a la cola "+proc.getNombre());*/
                espera = 0;
            }
            
        }
        //System.out.println("termino en "+time);
        
        for(int i = 0; i < terminado.size(); i++)
        {
            //espera, entrega, throughtput, respuesta
            Object data[] = {terminado.get(i).getNombre(),terminado.get(i).getT_espera() ,terminado.get(i).getT_entrega(),(unidadT / terminado.get(i).getT_entrega()),terminado.get(i).getT_llegada()};
            dtm2.addRow(data);
        }
        terminado.clear();        
        promedioEspera();
        promedioEntrega();       
    }
}